package aufgabe2;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;


public class RecordsManagement implements Serializable{
	
	/**
	 * 
	 */
	private static final long serialVersionUID = -3129410752019265150L;
	private HashMap<String,Station> stations = new HashMap<String,Station>();
	private HashMap<String,HashMap<Date,RecordFolder>> 
				stationfolders = new HashMap<String,HashMap<Date,RecordFolder>>();
	private HashMap<String,Parameter> parameters = new HashMap<String,Parameter>();
	private Units units_management;
	
	/**
	 * CONSTRUCTOR
	 * @param units_management : declares the unit management
	 */
	public RecordsManagement(Units units_management) {
		this.units_management = units_management;
	}
	/**
	 * Adds a new Station to the HashMap
	 * @param name
	 * @param password
	 * @param id
	 * @return
	 */
	public boolean addStation(String name, String password, int id) {		
		Station stat = new Station(name,password,id);
		stations.put(name,stat);
		return true;
	}
	/**
	 * Returns a Station by name
	 * @param name
	 * @return
	 */
	public Station getStation(String name) {		
		return stations.get(name);
	}
	/**
	 * Deletes a Station
	 * @param name
	 * @return
	 */
	public boolean deleteStation(String name) {
		stations.remove(name);
		return true;
	}
	/**
	 * Returns station
	 * @return
	 */
	public String StationToString(String station_name) {
		
		String output;
		output = "================ " + station_name + " ================\n";			
		output += "Total Record Folders: " + stationfolders.get(station_name).size() + "\n";
		
		return output;
	}
	/**
	 * Adds a new RecordFolder to the HashMap
	 * The key is generated by station name and the folders date
	 * @param timestamp
	 * @param station
	 * @return
	 */
	public String addRecordFolder(Date timestamp, Station station) {		
		int id = station.getId();
		String station_name = station.getName();
		HashMap<Date,RecordFolder> station_map = stationfolders.get(station_name);
		RecordFolder recordfolder = new RecordFolder(id,timestamp,station); 
		
		if(station_map != null) {
			if(station_map.containsKey(timestamp)) {
				return "Fehler: RecordFolder fuer diesen Zeitpunkt schon vorhanden!";
			} else {
				stationfolders.get(station_name).put(timestamp, recordfolder);
				return "Erfolgreich hinzugefuegt!";
			}
		} else {
			HashMap<Date,RecordFolder> newFolder = new HashMap<Date,RecordFolder>();
			stationfolders.put(station_name,newFolder);
			stationfolders.get(station_name).put(timestamp, recordfolder);
			return "Erfolgreich hinzugefuegt!";
		}
		
		
	}
	/**
	 * Returns the RecordFolder by Date and Station name
	 * @param timestamp
	 * @param station_name
	 * @return
	 */
	public RecordFolder getRecordFolder(Date timestamp, String station_name) {		
		return stationfolders.get(station_name).get(timestamp);
	}
	/**
	 * Adds a new Record to the specific Folder
	 * @param timestamp
	 * @param station_name
	 * @param value
	 * @param param
	 * @param device
	 * @return
	 */
	public String addNewRecordToFolder(Date timestamp, String station_name, 
			float value, String param, String device) {
		
		RecordFolder folder = getRecordFolder(timestamp,station_name);
		Parameter parameter = getParameterByName(param);	
		float base_value = units_management.getBaseUnitValue(device, value);
		Record record = new Record(base_value, parameter);
		
		if(checkIfUnderMinValue(param, base_value)) {
			return "Fehler: Wert liegt unter dem Messrahmen!";
		} else if(checkIfOverMaxValue(param, base_value)) {
			return "Fehler: Wert liegt ueber dem Messrahmen!";
		} else if(checkIfOverThreshold(param, base_value)) {
			folder.addRecord(record);
			return "Warnung: Wert liegt ueber dem Grenzwert!";
		} else {
			folder.addRecord(record);
			return "Wert wurde hinzugefuegt!";	
		}			
	}
	/**
	 * Returns a list of Record Folders between two Dates from one or all stations
	 * If @param station_name equals "Alle" the method returns all 
	 * stations with their record folders between two Dates
	 * @param station_name
	 * @param from
	 * @param to
	 * @return
	 */
	public String getRecordFoldersBetweenDates(String station_name, Date from, Date to) {
		String output = "";
		if(from.after(to))
			return "Fehler: Startzeit liegt nach der Endzeit!\n";
		
		if(station_name.equals("Alle")) {
			
			/*
			 * Load all Stations ordered by station name
			 */
			List<String> sortedList = new ArrayList<String>();
			sortedList.addAll(stationfolders.keySet());
			Collections.sort(sortedList);		
			Iterator<String> iter = sortedList.iterator();
			
			while (iter.hasNext()) {
				String key = iter.next();
				output += StationToString(key);
				int i = 0;
				/* 
				 * Load record folders from station
				 */
				List<Date> sortedFolders = new ArrayList<Date>();
				HashMap<Date,RecordFolder> recordfolders = stationfolders.get(key);
				sortedFolders.addAll(recordfolders.keySet());
				Collections.sort(sortedFolders);		
				Iterator<Date> folder = sortedFolders.iterator();
				
				while(folder.hasNext()) {
					Date folder_key = folder.next();
					if(folder_key.after(from) && folder_key.before(to)) {
						output += stationfolders.get(key).get(folder_key).toString();
						i++;
					}
				}
				output += "Query findings: " + i + "\n";
			}
		} else {
			/* 
			 * Load record folders from one station
			 */
			List<Date> sortedFolders = new ArrayList<Date>();
			HashMap<Date,RecordFolder> recordfolders = stationfolders.get(station_name);
			sortedFolders.addAll(recordfolders.keySet());
			Collections.sort(sortedFolders);		
			Iterator<Date> folder = sortedFolders.iterator();
			int i = 0;
			while(folder.hasNext()) {
				Date folder_key = folder.next();
				if(folder_key.after(from) && folder_key.before(to)) {
					output += stationfolders.get(station_name).get(folder_key).toString();
					i++;
				}
			}
			output += "Query findings: " + i + "\n";
		}		
		
		return output;
	}
	/**
	 * Adds a Parameter to the HashMap.
	 * Returns true if added successfully.
	 * 
	 * @param name
	 * @param max_value
	 * @param min_value
	 * @param threshold
	 * @param sym
	 * @return
	 */
	public boolean addParameter(String name, float max_value, float min_value,
			float threshold, String sym) {
		Parameter par = new Parameter(name,max_value,min_value,threshold,sym);
		
		parameters.put(name,par);
		
		return true;
	}
	/**
	 * Deletes the parameter by the given name.
	 * 
	 * @param name
	 * @return
	 */
	public boolean deleteParameter(String name) {
		if(parameters.remove(name) != null) {
			return true;
		}
			return false;
	}
	/**
	 * Returns the Parameter instance by the given name
	 * 
	 * @param name
	 * @return
	 */
	public Parameter getParameterByName(String name) {
		return parameters.get(name);
	}
	/**
	 * Returns the (string) BaseUnit Symbol which is assigned to the Parameter.
	 * 
	 * @param name
	 * @return
	 */
	public String getBaseUnitSymbolByParamter(String name) {
		Parameter temp_par = parameters.get(name);
		
		return temp_par.getUnitSymbol();
	}
	/**
	 * Returns all parameters as an ArrayList.
	 * 
	 * @return
	 */
	public ArrayList<String> fetchParameters() {
		ArrayList<String> temp = new ArrayList<String>(parameters.keySet());
		
		return temp;
	}
	/**
	 * Returns true if the value is under the (given) parameter's min value.
	 * 
	 * @param parameter
	 * @param value
	 * @return
	 */
	public boolean checkIfUnderMinValue(String parameter,float value) {
		Parameter temp_par = this.getParameterByName(parameter);
		
		if(temp_par != null)
			if(value < temp_par.getMin_value())
				return true;

		return false;
	}
	/**
	 * Checks if value is over defined max value
	 * 
	 * @param parameter
	 * @param value
	 * @return
	 */
	public boolean checkIfOverMaxValue(String parameter,float value) {
		Parameter temp_par = this.getParameterByName(parameter);
		
		if(temp_par != null)
			if(value > temp_par.getMax_value())
				return true;
		
		return false;
	}
	/**
	 * Returns true if value is over defined threshold
	 * 
	 * @param paramter
	 * @param value
	 * @return
	 */
	public boolean checkIfOverThreshold(String parameter, float value) {
		Parameter temp_par = this.getParameterByName(parameter);
		
		if(temp_par != null)
			if(value > temp_par.getThreshold())
				return true;
		
		return false;
	}
}
